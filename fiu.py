# main.py - Discord Bot with PostgreSQL for persistent token storage
import os
import json
import asyncio
import threading
import discord
import aiohttp
import requests
from discord.ext import commands
from flask import Flask, request
from dotenv import load_dotenv
from urllib.parse import urlparse
import time

# Try to import psycopg2, fallback to JSON if not available
try:
    import psycopg2
    HAS_PSYCOPG2 = True
    print("‚úÖ psycopg2 imported successfully")
except ImportError:
    HAS_PSYCOPG2 = False
    print("‚ö†Ô∏è WARNING: psycopg2 not available, using JSON storage only")

# --- LOAD ENVIRONMENT VARIABLES ---
load_dotenv()
DISCORD_TOKEN = os.getenv('DISCORD_TOKEN')
CLIENT_ID = os.getenv('DISCORD_CLIENT_ID')
CLIENT_SECRET = os.getenv('DISCORD_CLIENT_SECRET')
DATABASE_URL = os.getenv('DATABASE_URL')
# >>> START: BI·∫æN M√îI TR∆Ø·ªúNG M·ªöI CHO JSONBIN.IO
JSONBIN_API_KEY = os.getenv('JSONBIN_API_KEY')
JSONBIN_BIN_ID = os.getenv('JSONBIN_BIN_ID')
# <<< END: BI·∫æN M√îI TR∆Ø·ªúNG M·ªöI

if not DISCORD_TOKEN:
    exit("L·ªñI: Kh√¥ng t√¨m th·∫•y DISCORD_TOKEN")
if not CLIENT_ID:
    exit("L·ªñI: Kh√¥ng t√¨m th·∫•y DISCORD_CLIENT_ID")
if not CLIENT_SECRET:
    exit("L·ªñI: Kh√¥ng t√¨m th·∫•y DISCORD_CLIENT_SECRET")

# --- RENDER CONFIGURATION ---
PORT = int(os.getenv('PORT', 5000))
RENDER_URL = os.getenv('RENDER_EXTERNAL_URL', f'http://127.0.0.1:{PORT}')
REDIRECT_URI = f'{RENDER_URL}/callback'

# --- DATABASE SETUP ---
def init_database():
    """Kh·ªüi t·∫°o database v√† t·∫°o b·∫£ng n·∫øu ch∆∞a c√≥"""
    if not DATABASE_URL or not HAS_PSYCOPG2:
        print("‚ö†Ô∏è WARNING: Kh√¥ng c√≥ DATABASE_URL ho·∫∑c psycopg2, s·ª≠ d·ª•ng file JSON backup")
        return False
    
    try:
        conn = psycopg2.connect(DATABASE_URL, sslmode='require')
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS user_tokens (
                user_id VARCHAR(50) PRIMARY KEY,
                access_token TEXT NOT NULL,
                username VARCHAR(100),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        cursor.close()
        conn.close()
        print("‚úÖ Database initialized successfully")
        return True
        
    except Exception as e:
        print(f"‚ùå Database connection failed: {e}")
        print("üîÑ Falling back to JSON file storage")
        return False

# --- DATABASE FUNCTIONS ---
def get_db_connection():
    """T·∫°o connection t·ªõi database"""
    if DATABASE_URL and HAS_PSYCOPG2:
        try:
            return psycopg2.connect(DATABASE_URL, sslmode='require')
        except Exception as e:
            print(f"Database connection error: {e}")
            return None
    return None

def get_user_access_token_db(user_id: str):
    """L·∫•y access token t·ª´ database"""
    conn = get_db_connection()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT access_token FROM user_tokens WHERE user_id = %s", (user_id,))
            result = cursor.fetchone()
            cursor.close()
            conn.close()
            return result[0] if result else None
        except Exception as e:
            print(f"Database error: {e}")
            if conn:
                conn.close()
    return None

def save_user_token_db(user_id: str, access_token: str, username: str = None):
    """L∆∞u access token v√†o database"""
    conn = get_db_connection()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO user_tokens (user_id, access_token, username) 
                VALUES (%s, %s, %s)
                ON CONFLICT (user_id) 
                DO UPDATE SET 
                    access_token = EXCLUDED.access_token,
                    username = EXCLUDED.username,
                    updated_at = CURRENT_TIMESTAMP
            ''', (user_id, access_token, username))
            conn.commit()
            cursor.close()
            conn.close()
            print(f"‚úÖ Saved token for user {user_id} to database")
            return True
        except Exception as e:
            print(f"Database error: {e}")
            if conn:
                conn.close()
    return False

# --- START: CH·ª®C NƒÇNG L∆ØU TR·ªÆ JSON ƒê√ÅM M√ÇY (JSONBIN.IO) ---
def save_tokens_to_jsonbin(tokens_data):
    """L∆∞u to√†n b·ªô d·ªØ li·ªáu token l√™n JSONBin.io."""
    if not JSONBIN_API_KEY or not JSONBIN_BIN_ID:
        return False
    try:
        headers = {'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_API_KEY}
        url = f"https://api.jsonbin.io/v3/b/{JSONBIN_BIN_ID}"
        req = requests.put(url, json=tokens_data, headers=headers, timeout=15)
        if req.status_code == 200:
            print("‚úÖ ƒê√£ l∆∞u token l√™n JSONBin.io.")
            return True
        else:
            print(f"‚ö†Ô∏è L·ªói khi l∆∞u l√™n JSONBin.io: HTTP {req.status_code}")
            return False
    except Exception as e:
        print(f"‚ùå L·ªói k·∫øt n·ªëi t·ªõi JSONBin.io khi l∆∞u: {e}")
        return False

def load_tokens_from_jsonbin():
    """T·∫£i to√†n b·ªô d·ªØ li·ªáu token t·ª´ JSONBin.io."""
    if not JSONBIN_API_KEY or not JSONBIN_BIN_ID:
        return None
    try:
        headers = {'X-Master-Key': JSONBIN_API_KEY}
        url = f"https://api.jsonbin.io/v3/b/{JSONBIN_BIN_ID}/latest"
        req = requests.get(url, headers=headers, timeout=15)
        if req.status_code == 200:
            record = req.json().get("record", {})
            print("‚úÖ ƒê√£ t·∫£i token t·ª´ JSONBin.io.")
            return record
        else:
            print(f"‚ö†Ô∏è L·ªói khi t·∫£i t·ª´ JSONBin.io: HTTP {req.status_code}")
            return None
    except Exception as e:
        print(f"‚ùå L·ªói k·∫øt n·ªëi t·ªõi JSONBin.io: {e}")
        return None
# --- END: CH·ª®C NƒÇNG L∆ØU TR·ªÆ JSON ƒê√ÅM M√ÇY ---

# --- START: C·∫¢I TI·∫æN L∆ØU TR·ªÆ JSON V·ªöI CACHE ---
_token_cache = {}
_cache_loaded = False

def load_all_tokens():
    """T·∫£i t·∫•t c·∫£ token t·ª´ ngu·ªìn ∆∞u ti√™n (JSONBin > local file) v√†o cache."""
    global _token_cache, _cache_loaded
    if _cache_loaded:
        return

    # 1. ∆Øu ti√™n t·∫£i t·ª´ JSONBin.io
    tokens_from_cloud = load_tokens_from_jsonbin()
    if tokens_from_cloud is not None:
        _token_cache = tokens_from_cloud
        _cache_loaded = True
        return

    # 2. Fallback: T·∫£i t·ª´ file local
    print("üîÑ Cloud storage not available or failed, falling back to local tokens.json")
    try:
        with open('tokens.json', 'r') as f:
            _token_cache = json.load(f)
        print("‚úÖ ƒê√£ t·∫£i token t·ª´ file JSON local.")
    except (FileNotFoundError, json.JSONDecodeError):
        _token_cache = {}
        print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file tokens.json ho·∫∑c file b·ªã l·ªói, b·∫Øt ƒë·∫ßu v·ªõi cache tr·ªëng.")
    
    _cache_loaded = True

def persist_all_tokens():
    """L∆∞u cache token hi·ªán t·∫°i v√†o file local v√† JSONBin.io."""
    # Lu√¥n l∆∞u v√†o file local l√†m backup
    try:
        with open('tokens.json', 'w') as f:
            json.dump(_token_cache, f, indent=4)
        print("‚úÖ ƒê√£ l∆∞u token v√†o file backup JSON local.")
    except Exception as e:
        print(f"‚ùå L·ªói khi l∆∞u file JSON: {e}")
    
    # L∆∞u l√™n JSONBin.io n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh
    save_tokens_to_jsonbin(_token_cache)

def get_user_access_token_json(user_id: str):
    """L·∫•y token t·ª´ cache."""
    user_id_str = str(user_id)
    data = _token_cache.get(user_id_str)
    if isinstance(data, dict):
        return data.get('access_token')
    return data  # H·ªó tr·ª£ c·∫•u tr√∫c c≈©

def save_user_token_json(user_id: str, access_token: str, username: str = None):
    """L∆∞u token v√†o cache v√† sau ƒë√≥ persist ra c√°c ngu·ªìn l∆∞u tr·ªØ."""
    global _token_cache
    _token_cache[user_id] = {
        'access_token': access_token,
        'username': username,
        'updated_at': str(time.time())
    }
    persist_all_tokens()
    return True
# --- END: C·∫¢I TI·∫æN L∆ØU TR·ªÆ JSON ---

# --- UNIFIED TOKEN FUNCTIONS ---
def get_user_access_token(user_id: int):
    """L·∫•y access token (∆∞u ti√™n database, fallback JSON cache)"""
    user_id_str = str(user_id)
    
    # Th·ª≠ database tr∆∞·ªõc
    token = get_user_access_token_db(user_id_str)
    if token:
        return token
    
    # Fallback ra JSON (t·ª´ cache)
    return get_user_access_token_json(user_id_str)

def save_user_token(user_id: str, access_token: str, username: str = None):
    """L∆∞u access token (database + JSONBin + JSON local)"""
    success_db = save_user_token_db(user_id, access_token, username)
    success_json = save_user_token_json(user_id, access_token, username)
    return success_db or success_json

# --- DISCORD BOT SETUP ---
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

# --- FLASK WEB SERVER SETUP ---
app = Flask(__name__)

# --- UTILITY FUNCTIONS ---
async def add_member_to_guild(guild_id: int, user_id: int, access_token: str):
    """Th√™m member v√†o guild s·ª≠ d·ª•ng Discord API tr·ª±c ti·∫øp"""
    url = f"https://discord.com/api/v10/guilds/{guild_id}/members/{user_id}"
    headers = {
        "Authorization": f"Bot {DISCORD_TOKEN}",
        "Content-Type": "application/json"
    }
    data = {
        "access_token": access_token
    }
    
    async with aiohttp.ClientSession() as session:
        async with session.put(url, headers=headers, json=data) as response:
            if response.status == 201:
                return True, "Th√™m th√†nh c√¥ng"
            elif response.status == 204:
                return True, "User ƒë√£ c√≥ trong server"
            else:
                error_text = await response.text()
                return False, f"HTTP {response.status}: {error_text}"

# --- DISCORD BOT EVENTS ---
@bot.event
async def on_ready():
    print(f'‚úÖ Bot ƒëƒÉng nh·∫≠p th√†nh c√¥ng: {bot.user.name}')
    print(f'üîó Web server: {RENDER_URL}')
    print(f'üîë Redirect URI: {REDIRECT_URI}')
    db_status = "Connected" if get_db_connection() else "Not Connected"
    json_status = "JSONBin.io" if JSONBIN_BIN_ID else "Local File Only"
    print(f'üíæ Database: {db_status}')
    print(f'üóÇÔ∏è JSON Storage: {json_status}')
    print('------')
    
# --- DISCORD BOT COMMANDS (Kh√¥ng thay ƒë·ªïi, gi·ªØ nguy√™n nh∆∞ c≈©) ---
@bot.command(name='ping', help='Ki·ªÉm tra ƒë·ªô tr·ªÖ k·∫øt n·ªëi c·ªßa bot.')
async def ping(ctx):
    latency = round(bot.latency * 1000)
    await ctx.send(f'üèì Pong! ƒê·ªô tr·ªÖ l√† {latency}ms.')

@bot.command(name='auth', help='L·∫•y link ·ªßy quy·ªÅn ƒë·ªÉ bot c√≥ th·ªÉ th√™m b·∫°n v√†o server.')
async def auth(ctx):
    auth_url = (
        f'https://discord.com/api/oauth2/authorize?client_id={CLIENT_ID}'
        f'&redirect_uri={REDIRECT_URI}&response_type=code&scope=identify%20guilds.join'
    )
    embed = discord.Embed(
        title="üîê ·ª¶y quy·ªÅn cho Bot",
        description=f"Nh·∫•p v√†o link b√™n d∆∞·ªõi ƒë·ªÉ cho ph√©p bot th√™m b·∫°n v√†o c√°c server:",
        color=0x00ff00
    )
    embed.add_field(name="üîó Link ·ªßy quy·ªÅn", value=f"[Nh·∫•p v√†o ƒë√¢y]({auth_url})", inline=False)
    embed.add_field(name="üìù L∆∞u √Ω", value="Token s·∫Ω ƒë∆∞·ª£c l∆∞u an to√†n tr√™n nhi·ªÅu l·ªõp (database, cloud, local) v√† kh√¥ng m·∫•t khi restart.", inline=False)
    await ctx.send(embed=embed)

@bot.command(name='add_me', help='Th√™m b·∫°n v√†o t·∫•t c·∫£ c√°c server c·ªßa bot.')
async def add_me(ctx):
    user_id = ctx.author.id
    await ctx.send(f"‚úÖ B·∫Øt ƒë·∫ßu qu√° tr√¨nh th√™m {ctx.author.mention} v√†o c√°c server...")
    
    access_token = get_user_access_token(user_id)
    if not access_token:
        embed = discord.Embed(
            title="‚ùå Ch∆∞a ·ªßy quy·ªÅn",
            description="B·∫°n ch∆∞a ·ªßy quy·ªÅn cho bot. H√£y s·ª≠ d·ª•ng l·ªánh `!auth` tr∆∞·ªõc.",
            color=0xff0000
        )
        await ctx.send(embed=embed)
        return
    
    success_count = 0
    fail_count = 0
    
    for guild in bot.guilds:
        try:
            member = guild.get_member(user_id)
            if member:
                print(f"üëç {ctx.author.name} ƒë√£ c√≥ trong server {guild.name}")
                success_count += 1
                continue
            
            success, message = await add_member_to_guild(guild.id, user_id, access_token)
            
            if success:
                print(f"üëç Th√™m th√†nh c√¥ng {ctx.author.name} v√†o server {guild.name}: {message}")
                success_count += 1
            else:
                print(f"üëé L·ªói khi th√™m v√†o {guild.name}: {message}")
                fail_count += 1
                
        except Exception as e:
            print(f"üëé L·ªói kh√¥ng x√°c ƒë·ªãnh khi th√™m v√†o {guild.name}: {e}")
            fail_count += 1
    
    embed = discord.Embed(title="üìä K·∫øt qu·∫£", color=0x00ff00)
    embed.add_field(name="‚úÖ Th√†nh c√¥ng", value=f"{success_count} server", inline=True)
    embed.add_field(name="‚ùå Th·∫•t b·∫°i", value=f"{fail_count} server", inline=True)
    await ctx.send(embed=embed)

@bot.command(name='check_token', help='Ki·ªÉm tra xem b·∫°n ƒë√£ ·ªßy quy·ªÅn ch∆∞a.')
async def check_token(ctx):
    user_id = ctx.author.id
    token = get_user_access_token(user_id)
    
    if token:
        embed = discord.Embed(
            title="‚úÖ ƒê√£ ·ªßy quy·ªÅn", 
            description="Bot ƒë√£ c√≥ token c·ªßa b·∫°n v√† c√≥ th·ªÉ th√™m b·∫°n v√†o server.",
            color=0x00ff00
        )
    else:
        embed = discord.Embed(
            title="‚ùå Ch∆∞a ·ªßy quy·ªÅn", 
            description="B·∫°n ch∆∞a ·ªßy quy·ªÅn cho bot. H√£y s·ª≠ d·ª•ng `!auth`.",
            color=0xff0000
        )
    
    await ctx.send(embed=embed)

@bot.command(name='status', help='Ki·ªÉm tra tr·∫°ng th√°i bot v√† database.')
async def status(ctx):
    db_connection = get_db_connection()
    db_status = "‚úÖ Connected" if db_connection else "‚ùå Disconnected"
    if db_connection:
        db_connection.close()
    
    json_status = "‚úÖ JSONBin.io" if (JSONBIN_API_KEY and JSONBIN_BIN_ID) else "‚ö†Ô∏è Local File Only"
    
    embed = discord.Embed(title="ü§ñ Tr·∫°ng th√°i Bot", color=0x0099ff)
    embed.add_field(name="üìä Server", value=f"{len(bot.guilds)} server", inline=True)
    embed.add_field(name="üë• Ng∆∞·ªùi d√πng", value=f"{len(bot.users)} user", inline=True)
    embed.add_field(name="üíæ Database", value=db_status, inline=False)
    embed.add_field(name="üóÇÔ∏è JSON Storage", value=json_status, inline=False)
    embed.add_field(name="üåê Web Server", value=f"[Truy c·∫≠p]({RENDER_URL})", inline=False)
    await ctx.send(embed=embed)
    
@bot.command(name='force_add', help='(Ch·ªß bot) Th√™m m·ªôt ng∆∞·ªùi d√πng b·∫•t k·ª≥ v√†o t·∫•t c·∫£ c√°c server.')
@commands.is_owner()
async def force_add(ctx, user_to_add: discord.User):
    user_id = user_to_add.id
    await ctx.send(f"‚úÖ ƒê√£ nh·∫≠n l·ªánh! B·∫Øt ƒë·∫ßu qu√° tr√¨nh th√™m {user_to_add.mention} v√†o c√°c server...")
    
    access_token = get_user_access_token(user_id)
    if not access_token:
        embed = discord.Embed(
            title="‚ùå Ng∆∞·ªùi d√πng ch∆∞a ·ªßy quy·ªÅn",
            description=f"Ng∆∞·ªùi d√πng {user_to_add.mention} ch∆∞a ·ªßy quy·ªÅn cho bot. H√£y y√™u c·∫ßu h·ªç s·ª≠ d·ª•ng l·ªánh `!auth` tr∆∞·ªõc.",
            color=0xff0000
        )
        await ctx.send(embed=embed)
        return
    
    success_count = 0
    fail_count = 0
    
    for guild in bot.guilds:
        try:
            member = guild.get_member(user_id)
            if member:
                print(f"üëç {user_to_add.name} ƒë√£ c√≥ trong server {guild.name}")
                success_count += 1
                continue
            
            success, message = await add_member_to_guild(guild.id, user_id, access_token)
            
            if success:
                print(f"üëç Th√™m th√†nh c√¥ng {user_to_add.name} v√†o server {guild.name}: {message}")
                success_count += 1
            else:
                print(f"üëé L·ªói khi th√™m v√†o {guild.name}: {message}")
                fail_count += 1
                
        except Exception as e:
            print(f"üëé L·ªói kh√¥ng x√°c ƒë·ªãnh khi th√™m v√†o {guild.name}: {e}")
            fail_count += 1
    
    embed = discord.Embed(title=f"üìä K·∫øt qu·∫£ th√™m {user_to_add.name}", color=0x00ff00)
    embed.add_field(name="‚úÖ Th√†nh c√¥ng", value=f"{success_count} server", inline=True)
    embed.add_field(name="‚ùå Th·∫•t b·∫°i", value=f"{fail_count} server", inline=True)
    await ctx.send(embed=embed)

@force_add.error
async def force_add_error(ctx, error):
    if isinstance(error, commands.NotOwner):
        await ctx.send("üö´ L·ªói: B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")
    elif isinstance(error, commands.UserNotFound):
        await ctx.send(f"‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh.")
    else:
        print(f"L·ªói khi th·ª±c thi l·ªánh force_add: {error}")
        await ctx.send(f"ƒê√£ c√≥ l·ªói x·∫£y ra khi th·ª±c thi l·ªánh. Vui l√≤ng ki·ªÉm tra console.")

# --- FLASK WEB ROUTES ---
@app.route('/')
def index():
    auth_url = (
        f'https://discord.com/api/oauth2/authorize?client_id={CLIENT_ID}'
        f'&redirect_uri={REDIRECT_URI}&response_type=code&scope=identify%20guilds.join'
    )
    return f'''
    <!DOCTYPE html>
    <html>
    <head>
        <title>Discord Bot Authorization</title>
        <style>
            body {{ font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 50px; }}
            .container {{ background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 30px; max-width: 600px; margin: 0 auto; }}
            .btn {{ background: #7289da; color: white; padding: 15px 30px; border: none; border-radius: 5px; font-size: 18px; text-decoration: none; display: inline-block; margin: 20px; transition: background 0.3s; }}
            .btn:hover {{ background: #5865f2; }}
            .info {{ background: rgba(255, 255, 255, 0.05); border-radius: 10px; padding: 15px; margin: 20px 0; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ü§ñ Discord Bot Authorization</h1>
            <p>Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi h·ªá th·ªëng ·ªßy quy·ªÅn Discord Bot!</p>
            <div class="info">
                <h3>üíæ Persistent Storage</h3>
                <p>Token c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c l∆∞u an to√†n tr√™n nhi·ªÅu l·ªõp (database, cloud, local) v√† kh√¥ng b·ªã m·∫•t khi restart service.</p>
            </div>
            <a href="{auth_url}" class="btn">üîê ƒêƒÉng nh·∫≠p v·ªõi Discord</a>
            <div class="info">
                <h3>üìã C√°c l·ªánh bot:</h3>
                <p><code>!force_add &lt;User_ID&gt;</code> - (Ch·ªß bot) Th√™m ng∆∞·ªùi d√πng b·∫•t k·ª≥</p>
                <p><code>!auth</code> - L·∫•y link ·ªßy quy·ªÅn</p>
                <p><code>!add_me</code> - Th√™m b·∫°n v√†o server</p>
                <p><code>!check_token</code> - Ki·ªÉm tra tr·∫°ng th√°i token</p>
                <p><code>!status</code> - Tr·∫°ng th√°i bot</p>
            </div>
        </div>
    </body>
    </html>
    '''

@app.route('/callback')
def callback():
    code = request.args.get('code')
    if not code:
        return "‚ùå L·ªói: Kh√¥ng nh·∫≠n ƒë∆∞·ª£c m√£ ·ªßy quy·ªÅn t·ª´ Discord.", 400

    token_url = 'https://discord.com/api/v10/oauth2/token'
    payload = { 'client_id': CLIENT_ID, 'client_secret': CLIENT_SECRET, 'grant_type': 'authorization_code', 'code': code, 'redirect_uri': REDIRECT_URI, }
    headers = {'Content-Type': 'application/x-www-form-urlencoded'}

    token_response = requests.post(token_url, data=payload, headers=headers)
    if token_response.status_code != 200:
        return f"‚ùå L·ªói khi l·∫•y token: {token_response.text}", 500
    
    token_data = token_response.json()
    access_token = token_data['access_token']

    user_info_url = 'https://discord.com/api/v10/users/@me'
    headers = {'Authorization': f'Bearer {access_token}'}
    user_response = requests.get(user_info_url, headers=headers)
    
    if user_response.status_code != 200:
        return "‚ùå L·ªói: Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ng∆∞·ªùi d√πng.", 500

    user_data = user_response.json()
    user_id = user_data['id']
    username = user_data['username']

    # L∆∞u token
    save_user_token(user_id, access_token, username)
    
    # --- C·∫≠p nh·∫≠t th√¥ng b√°o l∆∞u tr·ªØ ---
    storage_locations = []
    if DATABASE_URL and HAS_PSYCOPG2: storage_locations.append("database")
    if JSONBIN_BIN_ID: storage_locations.append("JSONBin.io (cloud)")
    storage_locations.append("file backup local")
    storage_info = " v√† ".join(storage_locations)

    return f'''
    <!DOCTYPE html>
    <html>
    <head>
        <title>·ª¶y quy·ªÅn th√†nh c√¥ng!</title>
        <style>
            body {{ font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 50px; }}
            .container {{ background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 30px; max-width: 600px; margin: 0 auto; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>‚úÖ Th√†nh c√¥ng!</h1>
            <p>C·∫£m ∆°n <strong>{username}</strong>!</p>
            <p>üéâ Token c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o: {storage_info}.</p>
            <p>üìù S·ª≠ d·ª•ng <code>!add_me</code> trong Discord ƒë·ªÉ v√†o server.</p>
            <p>üîí Token s·∫Ω kh√¥ng b·ªã m·∫•t khi service restart.</p>
        </div>
    </body>
    </html>
    '''

@app.route('/health')
def health():
    """Health check endpoint"""
    db_connection = get_db_connection()
    db_status = db_connection is not None
    if db_connection:
        db_connection.close()
    
    return { "status": "ok", "bot_connected": bot.is_ready(), "database_connected": db_status, "has_psycopg2": HAS_PSYCOPG2, "jsonbin_configured": bool(JSONBIN_BIN_ID) }

# --- THREADING FUNCTION ---
def run_flask():
    app.run(host='0.0.0.0', port=PORT, debug=False)

# --- MAIN EXECUTION ---
if __name__ == '__main__':
    print("üöÄ ƒêang kh·ªüi ƒë·ªông Discord Bot + Web Server...")
    print(f"üîß PORT: {PORT}")
    print(f"üîß Render URL: {RENDER_URL}")
    
    # Kh·ªüi t·∫°o database
    database_initialized = init_database()
    
    # T·∫£i t·∫•t c·∫£ token v√†o cache khi kh·ªüi ƒë·ªông
    load_all_tokens()
    
    try:
        # Ch·∫°y Flask server trong thread ri√™ng
        flask_thread = threading.Thread(target=run_flask, daemon=True)
        flask_thread.start()
        print(f"üåê Web server started on port {PORT}")
        
        time.sleep(2)
        
        # Ch·∫°y Discord bot
        print("ü§ñ Starting Discord bot...")
        bot.run(DISCORD_TOKEN)
        
    except Exception as e:
        print(f"‚ùå Startup error: {e}")
        print("üîÑ Keeping web server alive...")
        while True:
            time.sleep(60)
