# main.py (Phi√™n b·∫£n OCR N√ÇNG C·∫§P - C·∫£i thi·ªán thu·∫≠t to√°n c·∫Øt ·∫£nh)

import discord
from discord.ext import commands
import os
import re
import requests
import io
from PIL import Image, ImageEnhance, ImageFilter
from dotenv import load_dotenv
import threading
from flask import Flask
import asyncio
import pytesseract
import numpy as np

# --- PH·∫¶N 1: C·∫§U H√åNH WEB SERVER ---
app = Flask(__name__)

@app.route('/')
def home():
    return "Bot Discord ƒëang ho·∫°t ƒë·ªông."

def run_web_server():
    port = int(os.environ.get('PORT', 10000))
    app.run(host='0.0.0.0', port=port)

# --- PH·∫¶N 2: C·∫§U H√åNH V√Ä C√ÅC H√ÄM C·ª¶A BOT DISCORD ---
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')

KARUTA_ID = 646937666251915264
NEW_CHARACTERS_FILE = "new_characters.txt"
HEART_DATABASE_FILE = "tennhanvatvasotim.txt"

def load_heart_data(file_path):
    heart_db = {}
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line.startswith('‚ô°') or not line: 
                    continue
                parts = line.split('¬∑')
                if len(parts) >= 2:
                    try:
                        heart_str = parts[0].replace('‚ô°', '').replace(',', '').strip()
                        hearts = int(heart_str)
                        name = parts[-1].lower().strip()
                        if name: 
                            heart_db[name] = hearts
                    except (ValueError, IndexError): 
                        continue
    except FileNotFoundError:
        print(f"L·ªñI: Kh√¥ng t√¨m th·∫•y t·ªáp d·ªØ li·ªáu '{file_path}'.")
    
    print(f"‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng {len(heart_db)} nh√¢n v·∫≠t v√†o c∆° s·ªü d·ªØ li·ªáu s·ªë tim.")
    return heart_db

HEART_DATABASE = load_heart_data(HEART_DATABASE_FILE)

def log_new_character(character_name):
    try:
        existing_names = set()
        if os.path.exists(NEW_CHARACTERS_FILE):
            with open(NEW_CHARACTERS_FILE, 'r', encoding='utf-8') as f:
                existing_names = set(line.strip().lower() for line in f)
        
        if character_name and character_name.lower() not in existing_names:
            with open(NEW_CHARACTERS_FILE, 'a', encoding='utf-8') as f:
                f.write(f"{character_name}\n")
            print(f"  [LOG] ‚≠ê ƒê√£ l∆∞u nh√¢n v·∫≠t m·ªõi '{character_name}' v√†o file {NEW_CHARACTERS_FILE}")
    except Exception as e:
        print(f"L·ªói khi ƒëang l∆∞u nh√¢n v·∫≠t m·ªõi: {e}")

def advanced_image_preprocessing(image):
    """Ti·ªÅn x·ª≠ l√Ω ·∫£nh n√¢ng cao cho OCR"""
    try:
        # Chuy·ªÉn sang RGB n·∫øu c·∫ßn
        if image.mode not in ['RGB', 'L']:
            image = image.convert('RGB')
        
        # Chuy·ªÉn sang grayscale
        if image.mode != 'L':
            image = image.convert('L')
        
        # TƒÉng k√≠ch th∆∞·ªõc g·∫•p 3 l·∫ßn
        width, height = image.size
        image = image.resize((width * 3, height * 3), Image.Resampling.LANCZOS)
        
        # TƒÉng ƒë·ªô s·∫Øc n√©t
        image = image.filter(ImageFilter.SHARPEN)
        
        # TƒÉng contrast m·∫°nh
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(2.5)
        
        # TƒÉng ƒë·ªô s√°ng m·ªôt ch√∫t
        enhancer = ImageEnhance.Brightness(image)
        image = enhancer.enhance(1.2)
        
        return image
    except Exception as e:
        print(f"  [L·ªñI] L·ªói ti·ªÅn x·ª≠ l√Ω ·∫£nh: {e}")
        return image

def extract_card_regions(img):
    """
    Tr√≠ch xu·∫•t ch√≠nh x√°c 3 v√πng th·∫ª b√†i t·ª´ ·∫£nh Karuta
    D·ª±a tr√™n ph√¢n t√≠ch c·∫•u tr√∫c ·∫£nh th·ª±c t·∫ø
    """
    width, height = img.size
    print(f"  [EXTRACT] Ph√¢n t√≠ch ·∫£nh k√≠ch th∆∞·ªõc: {width}x{height}")
    
    # Karuta th∆∞·ªùng c√≥ layout c·ªë ƒë·ªãnh v·ªõi 3 th·∫ª x·∫øp ngang
    # M·ªói th·∫ª chi·∫øm ~1/3 chi·ªÅu r·ªông
    
    cards = []
    card_width = width // 3
    
    for i in range(3):
        # T√≠nh to√°n v√πng cho m·ªói th·∫ª
        x_start = i * card_width
        x_end = x_start + card_width
        
        # C·∫Øt to√†n b·ªô th·∫ª
        card_img = img.crop((x_start, 0, x_end, height))
        
        # Ph√¢n t√≠ch v√πng t√™n v√† m√£ s·ªë
        card_height = card_img.size[1]
        card_width_actual = card_img.size[0]
        
        # V√ôNG T√äN: Th∆∞·ªùng ·ªü ph·∫ßn tr√™n c·ªßa th·∫ª (20-35% t·ª´ tr√™n xu·ªëng)
        name_top = int(card_height * 0.05)    # 5% t·ª´ tr√™n
        name_bottom = int(card_height * 0.35)  # 35% t·ª´ tr√™n
        name_left = int(card_width_actual * 0.05)  # 5% t·ª´ tr√°i
        name_right = int(card_width_actual * 0.95) # 95% t·ª´ tr√°i
        
        name_region = card_img.crop((name_left, name_top, name_right, name_bottom))
        
        # V√ôNG M√É S·ªê: Th∆∞·ªùng ·ªü g√≥c d∆∞·ªõi ph·∫£i (85-95% t·ª´ tr√™n xu·ªëng)
        code_top = int(card_height * 0.85)     # 85% t·ª´ tr√™n
        code_bottom = int(card_height * 0.98)  # 98% t·ª´ tr√™n  
        code_left = int(card_width_actual * 0.3)   # 30% t·ª´ tr√°i
        code_right = int(card_width_actual * 0.95) # 95% t·ª´ tr√°i
        
        code_region = card_img.crop((code_left, code_top, code_right, code_bottom))
        
        cards.append({
            'index': i + 1,
            'full_card': card_img,
            'name_region': name_region,
            'code_region': code_region
        })
        
        print(f"  [EXTRACT] Th·∫ª {i+1}: T√™n({name_left},{name_top},{name_right},{name_bottom}) | M√£({code_left},{code_top},{code_right},{code_bottom})")
    
    return cards

async def get_names_from_image_ocr(image_bytes):
    """
    OCR n√¢ng cao v·ªõi thu·∫≠t to√°n c·∫£i ti·∫øn
    """
    try:
        img = Image.open(io.BytesIO(image_bytes))
        original_size = img.size
        print(f"  [OCR] ·∫¢nh g·ªëc: {original_size[0]}x{original_size[1]}")
        
        # Ki·ªÉm tra k√≠ch th∆∞·ªõc h·ª£p l·ªá
        if original_size[0] < 500 or original_size[1] < 200:
            print(f"  [OCR] ·∫¢nh qu√° nh·ªè, b·ªè qua.")
            return []
        
        # Tr√≠ch xu·∫•t c√°c v√πng th·∫ª
        cards = extract_card_regions(img)
        processed_data = []
        
        for card in cards:
            try:
                print(f"  [OCR] X·ª≠ l√Ω th·∫ª {card['index']}...")
                
                # Ti·ªÅn x·ª≠ l√Ω v√πng t√™n
                name_img = advanced_image_preprocessing(card['name_region'])
                
                # Ti·ªÅn x·ª≠ l√Ω v√πng m√£
                code_img = advanced_image_preprocessing(card['code_region'])
                
                # C·∫•u h√¨nh OCR cho t√™n (cho ph√©p ch·ªØ c√°i, s·ªë, d·∫•u c√°ch, d·∫•u ch·∫•m, d·∫•u g·∫°ch)
                name_config = r"--psm 6 --oem 3 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .'-"
                
                # C·∫•u h√¨nh OCR cho m√£ s·ªë (ch·ªâ s·ªë v√† d·∫•u #)
                code_config = r"--psm 7 --oem 3 -c tessedit_char_whitelist=0123456789#"
                
                # Th·ª±c hi·ªán OCR
                char_name = pytesseract.image_to_string(name_img, config=name_config, lang='eng').strip()
                print_number = pytesseract.image_to_string(code_img, config=code_config, lang='eng').strip()
                
                # L√†m s·∫°ch k·∫øt qu·∫£ t√™n
                if char_name:
                    # Lo·∫°i b·ªè k√Ω t·ª± kh√¥ng mong mu·ªën
                    char_name = re.sub(r'[^\w\s.\'-]', '', char_name)
                    # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
                    char_name = re.sub(r'\s+', ' ', char_name).strip()
                    
                    # Ki·ªÉm tra ƒë·ªô d√†i h·ª£p l√Ω (t√™n th·∫≠t th∆∞·ªùng > 2 k√Ω t·ª±)
                    if len(char_name) >= 2:
                        # L√†m s·∫°ch m√£ s·ªë
                        if print_number:
                            print_number = re.sub(r'[^0123456789#]', '', print_number)
                            if not print_number.startswith('#') and print_number.isdigit():
                                print_number = '#' + print_number
                        else:
                            print_number = "???"
                        
                        processed_data.append((char_name, print_number))
                        print(f"  [OCR] ‚úÖ Th·∫ª {card['index']}: '{char_name}' - '{print_number}'")
                    else:
                        print(f"  [OCR] ‚ùå Th·∫ª {card['index']}: T√™n qu√° ng·∫Øn: '{char_name}'")
                else:
                    print(f"  [OCR] ‚ùå Th·∫ª {card['index']}: Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c t√™n")
                    
            except Exception as card_error:
                print(f"  [OCR] ‚ùå L·ªói x·ª≠ l√Ω th·∫ª {card['index']}: {card_error}")
                continue
        
        print(f"  [OCR] üéØ Ho√†n th√†nh: {len(processed_data)}/{len(cards)} th·∫ª ƒë∆∞·ª£c nh·∫≠n d·∫°ng")
        return processed_data
        
    except Exception as e:
        print(f"  [OCR] ‚ùå L·ªói t·ªïng qu√°t: {e}")
        import traceback
        traceback.print_exc()
        return []

# --- PH·∫¶N CH√çNH C·ª¶A BOT ---
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

@bot.event
async def on_ready():
    print(f'‚úÖ Bot Discord ƒë√£ ƒëƒÉng nh·∫≠p v·ªõi t√™n {bot.user}')
    print('üîß Bot s·ª≠ d·ª•ng OCR n√¢ng cao v·ªõi thu·∫≠t to√°n c·∫£i ti·∫øn')
    
    # Test Tesseract
    try:
        version = pytesseract.get_tesseract_version()
        print(f'‚úÖ Tesseract version: {version}')
        
        # Test OCR ƒë∆°n gi·∫£n
        test_img = Image.new('L', (100, 30), color=255)
        test_result = pytesseract.image_to_string(test_img).strip()
        print(f'‚úÖ Tesseract test: OK')
        
    except Exception as e:
        print(f'‚ùå L·ªñI Tesseract: {e}')
        print('üí° H∆∞·ªõng d·∫´n c√†i ƒë·∫∑t:')
        print('   - Ubuntu: sudo apt-get install tesseract-ocr tesseract-ocr-eng')
        print('   - Windows: T·∫£i t·ª´ GitHub UB-Mannheim/tesseract')

@bot.event
async def on_message(message):
    # Ki·ªÉm tra tin nh·∫Øn t·ª´ Karuta v·ªõi ·∫£nh ƒë√≠nh k√®m
    if message.author.id != KARUTA_ID or not message.attachments:
        return
    
    attachment = message.attachments[0]
    if not (attachment.content_type and attachment.content_type.startswith('image/')):
        return

    print("\n" + "üé¥"*20 + " KARUTA DETECTED " + "üé¥"*20)
    print(f"üìé File: {attachment.filename}")
    print(f"üìè Size: {attachment.size:,} bytes")
    print(f"üîó URL: {attachment.url}")

    try:
        # T·∫£i ·∫£nh v·ªõi timeout tƒÉng
        print("‚¨áÔ∏è  ƒêang t·∫£i ·∫£nh...")
        response = requests.get(attachment.url, timeout=45)
        response.raise_for_status()
        image_bytes = response.content
        print(f"‚úÖ T·∫£i th√†nh c√¥ng: {len(image_bytes):,} bytes")

        # B·∫Øt ƒë·∫ßu OCR
        print("üîç B·∫Øt ƒë·∫ßu nh·∫≠n d·∫°ng OCR...")
        character_data = await get_names_from_image_ocr(image_bytes)
        
        if not character_data:
            print("‚ùå Kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ ·∫£nh")
            print("üé¥" + "="*58 + "üé¥\n")
            return

        # G·ª≠i ph·∫£n h·ªìi
        async with message.channel.typing():
            await asyncio.sleep(0.8)  # Th·ªùi gian typing t·ª± nhi√™n
            
            reply_lines = []
            for i, (name, print_number) in enumerate(character_data):
                lookup_name = name.lower().strip()
                
                # Log nh√¢n v·∫≠t m·ªõi
                if lookup_name not in HEART_DATABASE:
                    log_new_character(name)

                # Tra c·ª©u s·ªë tim
                heart_value = HEART_DATABASE.get(lookup_name, 0)
                heart_display = f"{heart_value:,}" if heart_value > 0 else "N/A"
                
                reply_lines.append(f"{i+1} | ‚ô°**{heart_display}** ¬∑ `{name}` `{print_number}`")
            
            reply_content = "\n".join(reply_lines)
            await message.reply(reply_content)
            
            print("üì§ Ph·∫£n h·ªìi ƒë√£ g·ª≠i:")
            for line in reply_lines:
                print(f"   {line}")

    except requests.Timeout:
        print("‚è∞ Timeout khi t·∫£i ·∫£nh")
    except requests.RequestException as e:
        print(f"üåê L·ªói m·∫°ng: {e}")
    except Exception as e:
        print(f"üí• L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}")
        import traceback
        traceback.print_exc()
    
    print("üé¥" + "="*58 + "üé¥\n")

@bot.command(name='testocr')
async def test_ocr_command(ctx):
    """L·ªánh test OCR - g·ª≠i k√®m ·∫£nh"""
    if ctx.message.attachments:
        attachment = ctx.message.attachments[0]
        if attachment.content_type and attachment.content_type.startswith('image/'):
            try:
                response = requests.get(attachment.url, timeout=30)
                response.raise_for_status()
                
                await ctx.send("üîç ƒêang test OCR...")
                character_data = await get_names_from_image_ocr(response.content)
                
                if character_data:
                    result = "\n".join([f"{i+1}. `{name}` `{code}`" for i, (name, code) in enumerate(character_data)])
                    await ctx.send(f"üìã K·∫øt qu·∫£ OCR:\n{result}")
                else:
                    await ctx.send("‚ùå Kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c g√¨ t·ª´ ·∫£nh")
                    
            except Exception as e:
                await ctx.send(f"‚ùå L·ªói test OCR: {e}")
        else:
            await ctx.send("‚ùå File ƒë√≠nh k√®m kh√¥ng ph·∫£i l√† ·∫£nh")
    else:
        await ctx.send("‚ùå Vui l√≤ng ƒë√≠nh k√®m m·ªôt ·∫£nh ƒë·ªÉ test OCR\nS·ª≠ d·ª•ng: `!testocr` + ƒë√≠nh k√®m ·∫£nh")

# --- KH·ªûI ƒê·ªòNG ---
if __name__ == "__main__":
    if TOKEN:
        print("üîë Discord token found")
        
        def run_bot():
            try:
                bot.run(TOKEN)
            except Exception as e:
                print(f"‚ùå Bot error: {e}")
        
        bot_thread = threading.Thread(target=run_bot)
        bot_thread.daemon = True
        bot_thread.start()
        
        print("üöÄ Starting web server...")
        run_web_server()
    else:
        print("‚ùå DISCORD_TOKEN not found in .env file")
